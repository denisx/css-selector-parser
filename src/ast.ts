/**
 * CSS Selector AST root.
 * Contains list of CSS rules (separated by a comma in the input CSS selector string).
 */
export interface AstSelector {
    type: 'Selector';
    /**
     * List of CSS rules. Every rule contains conditions. Selector is considered matched once at least one rule matches.
     */
    rules: AstRule[];
}

/**
 * A single CSS rule that contains match conditions.
 * Can nest another rule with or without a combinator (i.e. `"div > span"`).
 * Generated by {@link ast.rule}.
 */
export interface AstRule {
    type: 'Rule';
    /** Tag definition. Can be either TagName (i.e. `"div"`) or WildcardTag (`"*"`) if defined. */
    tag?: AstTag;
    /** List of CSS classes (i.e. `".c1.c2"` -> `['c1', 'c2']`) */
    classNames?: string[];
    /** List of IDs (i.e. `"#root"` -> `['root']`). */
    ids?: string[];
    /** Pseudo-element (i.e. `"::before"` -> `'before'`). */
    pseudoElement?: string;
    /** Pseudo-classes (i.e. `":link"` -> `[{name: 'link'}]`). */
    pseudoClasses?: AstPseudoClass[];
    /** List of attributes (i.e. `"[href][role=button]"` -> `[{name: 'href'}, {name: 'role', operator: '=', value: {type: 'String', value: 'button'}}]`) */
    attributes?: AstAttribute[];
    /** Nested rule and combinator if specified, i.e. `"div > span"`. */
    nestedRule?: {
        /** Nested rule combinator (i.e. `">"`). */
        combinator?: string;
        /** Nested rule definition. */
        rule: AstRule;
    };
}

/** Named tag, i.e. `"div"`. */
export interface AstTagName {
    type: 'TagName';
    /** Tag name, i.e. `"div"`. */
    name: string;
    /** Namespace according to https://www.w3.org/TR/css3-namespace/ */
    namespace?: AstNamespace;
}
/** Wildcard tag: `*`. */
export interface AstWildcardTag {
    type: 'WildcardTag';
    /** Namespace according to https://www.w3.org/TR/css3-namespace/ */
    namespace?: AstNamespace;
}
export type AstTag = AstTagName | AstWildcardTag;

export interface AstNamespaceName {
    type: 'NamespaceName';
    name: string;
}
export interface AstWildcardNamespace {
    type: 'WildcardNamespace';
}
export interface AstNoNamespace {
    type: 'NoNamespace';
}
export type AstNamespace = AstNamespaceName | AstWildcardNamespace | AstNoNamespace;

export interface AstAttribute {
    type: 'Attribute';
    name: string;
    namespace?: AstNamespace;
    operator?: string;
    value?: AstString | AstSubstitution;
    caseSensitivityModifier?: string;
}

export interface AstPseudoClass {
    type: 'PseudoClass';
    name: string;
    argument?: AstPseudoClassArgument;
}

/**
 * String value. Can be used as attribute value of pseudo-class string value.
 * For instance `:lang(en)` -> `{type: 'AstPseudoClass'..., argument: {type: 'String', value: 'en'}}`.
 */
export interface AstString {
    type: 'String';
    value: string;
}

/**
 * Pseudo-class formula value. `a` is multiplier of `n` and `b` us added on top. Formula: `an + b`.
 * For instance `:nth-child(2n + 1)` -> `{type: 'AstPseudoClass'..., argument: {type: 'Formula', a: 2, b: 1}}`.
 */
export interface AstFormula {
    type: 'Formula';
    /** Multiplier of `n`. */
    a: number;
    /** Constant added to `a*n`. */
    b: number;
}

export interface AstFormulaOfSelector {
    type: 'FormulaOfSelector';
    a: number;
    b: number;
    selector: AstRule;
}
/** Substitution is not part of CSS spec, but rather a useful extension on top of CSS if you need to pass variables. */
export interface AstSubstitution {
    type: 'Substitution';
    /** Substitution name (i.e. `"$var"` -> `'var'`). */
    name: string;
}

/** Any pseudo-class argument type. */
export type AstPseudoClassArgument = AstSubstitution | AstSelector | AstString | AstFormula | AstFormulaOfSelector;

/** Any CSS element. */
export type AstEntity =
    | AstSelector
    | AstRule
    | AstTag
    | AstNamespace
    | AstPseudoClassArgument
    | AstPseudoClass
    | AstAttribute;

function astMethods<EN extends AstEntity>(type: EN['type']) {
    type GenInput = Omit<EN, 'type'>;
    return <GN extends string, CN extends string>(generatorName: GN, checkerName: CN) =>
        ({
            [generatorName]: (props: GenInput) => ({
                type,
                ...props
            }),
            [checkerName]: (entity: unknown): entity is EN =>
                typeof entity === 'object' && entity !== null && (entity as AstEntity).type === type
        } as {[K in GN]: {} extends GenInput ? (props?: GenInput) => EN : (props: GenInput) => EN} &
            {
                [K in CN]: (entity: unknown) => entity is EN;
            });
}

/**
 * AST structure generators and matchers.
 * For instance, `ast.selector({rules: [...]})` creates AstSelector and `ast.isSelector(...)` checks if
 * AstSelector was specified.
 */
export const ast = {
    ...astMethods<AstSelector>('Selector')('selector', 'isSelector'),
    ...astMethods<AstRule>('Rule')('rule', 'isRule'),
    ...astMethods<AstTagName>('TagName')('tagName', 'isTagName'),
    ...astMethods<AstWildcardTag>('WildcardTag')('wildcardTag', 'isWildcardTag'),
    ...astMethods<AstNamespaceName>('NamespaceName')('namespaceName', 'isNamespaceName'),
    ...astMethods<AstWildcardNamespace>('WildcardNamespace')('wildcardNamespace', 'isWildcardNamespace'),
    ...astMethods<AstNoNamespace>('NoNamespace')('noNamespace', 'isNoNamespace'),
    ...astMethods<AstAttribute>('Attribute')('attribute', 'isAttribute'),
    ...astMethods<AstPseudoClass>('PseudoClass')('pseudoClass', 'isPseudoClass'),
    ...astMethods<AstString>('String')('string', 'isString'),
    ...astMethods<AstFormula>('Formula')('formula', 'isFormula'),
    ...astMethods<AstFormulaOfSelector>('FormulaOfSelector')('formulaOfSelector', 'isFormulaOfSelector'),
    ...astMethods<AstSubstitution>('Substitution')('substitution', 'isSubstitution')
};
